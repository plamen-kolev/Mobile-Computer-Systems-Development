For this project, I decided to create a messaging webapp using Ruby On Rails and a variety of front-end techniques. The application's premise is that when a user sends a message to somebody who ignores it, the message becomes deleted and the sender receives 'karma' points as a result. With these karma points, angry emoticons can be sent.

During the architecture of the work, the front-end interaction was under-estimated and the assumption was made that the application can be done primarily with back-end scripting. The rationale was that any messaging real-time functionality will be pushed to a front-end library like jQuery.
I soon realised the limitations of doing it that way. It is generally difficult to notify user upon new messages, making it impossible to create instant client-server-client code for message passing.

During the attempt to tackle the problem, I received a recommendation from a friends and also read online articles about using JavaScript web sockets (socket.io). A quick evaluation was made by creating a sample chat application with limited capabilities. The main problem was that the front-end JavaScript was interacting with a web-server written in express (javascript), a language that I did not have any experience with. A decision was made to not attempt to use web sockets due to learning curve and time.

Instead, to use real-time chat service, I decided to use Twilio's programmable chat API. They provide the ability to simply create messaging channels and receive and send messages between two clients.
A significant chunk of work went into integrating Twilio with the existing solution, because at this point all the back-end logic was implemented.

In the process of writing front-end JavaScript that ties with Twilio's chat app, the code started becoming more and more difficult to manage and the feelings that this is not the right approach started appearing. I also wanted to use a helper library for messaging instead of using a ready-made implementation. The reasoning is that it will help me understand such applications when writing them in the future. At this point, I had written a jQuery and Twillio version of the app that worked and achieved the task of sending and ignoring messages.

At this stage I became interested in front-end framework development, as it gives the developer the power to do complex logic in the client's browser. Abstracting away the server code from the client code was step in the general direction. For the purpose of building the client code, I opted for using the framework Angular 2.

Initially, as stated in my logs, I found it very difficult to get started using it. Most of the concepts seemed unfamiliar and few attempts were made to create dummy projects that would give the enough knowledge to tackle the task. This time was mostly spent during the Easter vacation and is the time where the least progress was done for the project due to Angular's learning curve.

After the Easter break, I had enough time and knowledge to start rebuilding the application with all that experience in mind. I opted for starting a clean version of the code, but to borrow any old code that was performing reasonably to speed up the process.

During the stage where the authentication system was written, I found it difficult to implement. The server-side tools used are devise and Java Web Tokens. The idea is for a user to log in and receive a unique token used by Angular to prove user authenticity. These tools had a reasonable amount of documentation, but there were not much information of integrating them together. Other authentication modules were tried, but nothing yielded a positive effect. At the end, a decision was made to go back to integrating Java Web Token with devise. I found an article that explained the changes that ought to be made to enable such integration and after that, authentication on the server side was mostly finished.

The next issue I stumbled upon was interacting with the back-end server. When the change was made to support token based identity, the web browsers would stop working when authenticated content was displayed. During debugging, I learned that this is due to authentication requiring headers, which are not added automatically.

After trying to add server code for adding headers, I tried to switch from a browser to an API client and used Postman. This was generally in the right direction when debugging server-side code. Using this tool, I learned that it is much easier to find any issues as compared to using a browser. Postman lacks the ability to set custom headers easily, so later on I switched it to a tool called Advanced Rest client and have been using this tool ever since.

When writing the front-end code, numerous bugs were introduced due to lack of experience. Couple of bug fixing and improvement cycles were done to deliver a functioning product that is also maintainable.

Overall the project achieved its aim but it required a lot of changes as a result of lack of architecture planning and skills. As a result, in the near future I would rely more on the opinion of more experienced developers when receiving tool recommendation. In a real-world scenario,
